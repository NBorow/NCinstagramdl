import os
import re
import getpass
import json
import time
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
import requests

CONFIG_FILE = os.path.join(os.path.dirname(__file__), 'config.txt')
COOKIE_FILE = os.path.join(os.path.dirname(__file__), 'insta_cookies.txt')
PAGE_SIZE = 10

# --- New: Profile dump scan logic ---
PROFILE_POSTS_PATH = os.path.join('your_instagram_activity', 'media', 'posts_1.json')
LIKED_PATH = os.path.join('your_instagram_activity', 'likes', 'liked_posts.json')
SAVED_COLLECTIONS_PATH = os.path.join('your_instagram_activity', 'saved', 'saved_collections.json')
SAVED_POSTS_PATH = os.path.join('your_instagram_activity', 'saved', 'saved_posts.json')
DM_INBOX_PATH = os.path.join('your_instagram_activity', 'messages', 'inbox')

# Helper to check if a file exists and is non-empty
def file_exists_nonempty(path):
    return os.path.isfile(path) and os.path.getsize(path) > 0

def scan_profile_dump(dump_path):
    result = {'p': False, 'l': False, 's': False, 'd': False}
    posts_json = os.path.join(dump_path, PROFILE_POSTS_PATH)
    if file_exists_nonempty(posts_json):
        result['p'] = True
    liked_json = os.path.join(dump_path, LIKED_PATH)
    if file_exists_nonempty(liked_json):
        result['l'] = True
    saved_collections_json = os.path.join(dump_path, SAVED_COLLECTIONS_PATH)
    saved_posts_json = os.path.join(dump_path, SAVED_POSTS_PATH)
    if file_exists_nonempty(saved_collections_json) or file_exists_nonempty(saved_posts_json):
        result['s'] = True
    inbox_dir = os.path.join(dump_path, DM_INBOX_PATH)
    if os.path.isdir(inbox_dir):
        for root, dirs, files in os.walk(inbox_dir):
            if 'message_1.json' in files:
                msg_path = os.path.join(root, 'message_1.json')
                if file_exists_nonempty(msg_path):
                    result['d'] = True
                    break
    return result

# --- Cookie handling logic ---
def save_cookies_netscape(driver, cookie_file):
    cookies = driver.get_cookies()
    with open(cookie_file, "w") as f:
        f.write("# Netscape HTTP Cookie File\n")
        f.write("# Generated by NCInstagramDL\n\n")
        for cookie in cookies:
            domain = cookie.get('domain', '')
            domain_specified = 'TRUE' if domain.startswith('.') else 'FALSE'
            path = cookie.get('path', '/')
            secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
            expiry = str(cookie.get('expiry', 0)) if cookie.get('expiry') else '0'
            name = cookie.get('name', '')
            value = cookie.get('value', '')
            f.write(f"{domain}\t{domain_specified}\t{path}\t{secure}\t{expiry}\t{name}\t{value}\n")

def load_cookies_from_netscape(cookie_file):
    cookies = []
    try:
        with open(cookie_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith('#') or not line:
                    continue
                parts = line.split('\t')
                if len(parts) >= 7:
                    domain, domain_specified, path, secure, expiry, name, value = parts[:7]
                    if '.instagram.com' in domain or 'instagram.com' in domain:
                        cookies.append({
                            'name': name,
                            'value': value,
                            'domain': domain,
                            'path': path,
                            'secure': secure.lower() == 'true',
                            'expiry': int(expiry) if expiry.isdigit() else None
                        })
        return cookies
    except Exception:
        return []

def are_cookies_valid(cookie_file=COOKIE_FILE):
    if not os.path.exists(cookie_file):
        return False
    try:
        cookies = load_cookies_from_netscape(cookie_file)
        if not cookies:
            return False
        session = requests.Session()
        for cookie in cookies:
            session.cookies.set(cookie['name'], cookie['value'])
        resp = session.get("https://www.instagram.com/accounts/edit/", allow_redirects=False, timeout=10)
        return resp.status_code == 200
    except Exception:
        return False

# --- End cookie logic ---

def read_config():
    config = {}
    if not os.path.exists(CONFIG_FILE):
        print(f"Config file not found: {CONFIG_FILE}")
        exit(1)
    with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            if '=' in line:
                key, value = line.split('=', 1)
                config[key.strip()] = value.strip()
    return config

def verify_login_selenium_and_save_cookies(username, password):
    print('Attempting to login with Selenium and save cookies...')
    options = Options()
    # Non-headless for reliability (like dm_downloader)
    options.add_argument('--disable-gpu')
    options.add_argument('--window-size=1920,1080')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    try:
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=options)
        driver.get('https://www.instagram.com/accounts/login/')
        time.sleep(2)
        username_field = driver.find_element('name', 'username')
        username_field.clear()
        username_field.send_keys(username)
        password_field = driver.find_element('name', 'password')
        password_field.clear()
        password_field.send_keys(password)
        password_field.submit()
        time.sleep(4)
        if 'login' not in driver.current_url.lower():
            print('Login successful, saving cookies!')
            save_cookies_netscape(driver, COOKIE_FILE)
            driver.quit()
            return True
        page_source = driver.page_source
        if 'The username you entered doesn\'t belong to an account' in page_source or 'Sorry, your password was incorrect' in page_source:
            print('Login failed: incorrect username or password.')
            driver.quit()
            return False
        print('Login failed: still on login page.')
        driver.quit()
        return False
    except Exception as e:
        print(f"[Login Error] Exception during Selenium login: {e}")
        return False

def prompt_for_credentials(config):
    config_username = config.get('USERNAME')
    config_password = config.get('PASSWORD')
    username = config_username
    password = config_password
    if not username and password:
        password = None
    while True:
        if not username:
            username = input('Enter Instagram username: ').strip()
        if not password:
            password = input('Enter Instagram password (visible): ').strip()
        print(f"[DEBUG] Username entered: {repr(username)}")
        print(f"[DEBUG] Password entered: {repr(password)}")
        if verify_login_selenium_and_save_cookies(username, password):
            return username, password
        else:
            print('Login failed. Restart script if confident on credentials.')
            if config_username:
                # Only prompt for password again if username was from config.txt
                password = input('Enter Instagram password (visible): ').strip()
            else:
                username = input('Enter Instagram username: ').strip()
                password = input('Enter Instagram password (visible): ').strip()

def get_profile_dumps_dir():
    config = read_config()
    if 'PROFILE_DUMP_DIRECTORY' not in config:
        print("PROFILE_DUMP_DIRECTORY not set in config.txt")
        exit(1)
    return config['PROFILE_DUMP_DIRECTORY']

def get_profile_dumps():
    PROFILE_DUMPS_DIR = get_profile_dumps_dir()
    if not os.path.exists(PROFILE_DUMPS_DIR):
        print(f"Profile dumps directory not found: {PROFILE_DUMPS_DIR}")
        return []
    entries = []
    for name in os.listdir(PROFILE_DUMPS_DIR):
        full_path = os.path.join(PROFILE_DUMPS_DIR, name)
        if os.path.isdir(full_path):
            m = re.search(r'(\d{4}-\d{2}-\d{2})', name)
            date_str = m.group(1) if m else ''
            entries.append((name, full_path, date_str))
    entries.sort(key=lambda x: x[2], reverse=True)
    return [(name, path) for name, path, _ in entries]

def print_page(dumps, dump_availability, page):
    start = page * PAGE_SIZE
    end = start + PAGE_SIZE
    page_items = dumps[start:end]
    print("Select which profile dump to download from ({} available):".format(len(dumps)))
    print("Legend: [p] Profile Posts | [l] Liked | [s] Saved | [d] DMs\n")
    for idx, (name, _) in enumerate(page_items, start + 1):
        avail = dump_availability.get(name, {'p': False, 'l': False, 's': False, 'd': False})
        flags = ''.join([c if avail[c] else ' ' for c in 'plsd'])
        print(f"{idx:2d}. {name:<35} [{flags}]")
    if len(dumps) > PAGE_SIZE:
        if end < len(dumps):
            print("n) Next page")
        if page > 0:
            print("p) Previous page")
    print("q) Quit")

def print_options_menu(avail):
    options = []
    if avail['p']:
        options.append("Profile Posts Download")
    if avail['l']:
        options.append("Liked Posts Download")
    if avail['s']:
        options.append("Saved Posts Download")
    if avail['d']:
        options.append("DM Download")
    print("\nAvailable download options:")
    for i, opt in enumerate(options, 1):
        print(f"{i}. {opt}")
    print("q) Quit")
    return options

def main():
    config = read_config()
    # --- Cookie check: only login if cookies are missing/invalid ---
    first_check = True
    while not are_cookies_valid():
        if first_check:
            print("No valid cookies found. Login required.")
            first_check = False
        username, password = prompt_for_credentials(config)
        # After this, cookies will be saved if login is successful
        # Double-check cookies after login, loop if still invalid
        if not are_cookies_valid():
            print("[ERROR] Login failed or cookies could not be saved/validated. Please try again or Ctrl+C to quit.")
    if first_check:
        print("Valid Instagram cookies found. Skipping login.")
    # Proceed to main script
    dumps = get_profile_dumps()
    if not dumps:
        print("No profile dumps found.")
        return
    dump_availability = {}
    for name, path in dumps:
        dump_availability[name] = scan_profile_dump(path)
    page = 0
    while True:
        print_page(dumps, dump_availability, page)
        if len(dumps) > PAGE_SIZE:
            prompt_msg = "Enter your choice (number, n, p, q): "
            invalid_msg = f"Invalid option. Please enter a number between 1 and {len(dumps)}, 'n', 'p', or 'q'."
        else:
            prompt_msg = "Enter your choice (number, q): "
            invalid_msg = f"Invalid option. Please enter a number between 1 and {len(dumps)}, or 'q'."
        choice = input(prompt_msg).strip().lower()
        if choice.isdigit():
            num = int(choice)
            if 1 <= num <= len(dumps):
                selected = dumps[num - 1]
                selected_name, selected_path = selected
                avail = dump_availability[selected_name]
                options = print_options_menu(avail)
                if not options:
                    print("No download options available for this profile dump.")
                    input("Press Enter to return to main menu...")
                    continue
                while True:
                    opt_choice = input("Enter your choice (number or q): ").strip().lower()
                    if opt_choice == 'q':
                        break
                    if opt_choice.isdigit():
                        opt_num = int(opt_choice)
                        if 1 <= opt_num <= len(options):
                            print(f"You selected: {options[opt_num-1]}")
                            return opt_num
                        else:
                            print(f"Invalid option. Please enter a number between 1 and {len(options)}, or 'q'.")
                    else:
                        print(f"Invalid option. Please enter a number between 1 and {len(options)}, or 'q'.")
                break
            else:
                print(invalid_msg)
                input("Press Enter to continue...")
        elif len(dumps) > PAGE_SIZE and choice == 'n' and (page + 1) * PAGE_SIZE < len(dumps):
            page += 1
        elif len(dumps) > PAGE_SIZE and choice == 'p' and page > 0:
            page -= 1
        elif choice == 'q':
            print("Quitting.")
            break
        else:
            print(invalid_msg)
            input("Press Enter to continue...")

if __name__ == "__main__":
    main() 